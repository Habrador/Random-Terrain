#===============================================================================
# Particle Deposition
# http://gillesleblanc.wordpress.com/2012/10/16/creating-a-random-2d-game-world-map/
#===============================================================================

import random

def ParticleDeposition(GAME_WIDTH,GAME_HEIGHT):
    """
    Generate a heightmap using Particle Deposition - drop stones from the sky and make them roll to the closest resting place
    -Particle - one random point on the map generated by one drop
    -Drop point - generate particles randomly
    -Number of Drop points - how many drops will occur
    -Stability radius - how many points from the particle will we check if they are lower
    """
    #Parameters:
    #particles = 10 #Randomize inside of the iteration
    iterations = 500 #How many times we will fire the cannon with drop points
    stability_radius = 1 #How far away will we roll the particle to find a new resting place
    height_change = 1 #How much the z value will change
    #radius_cannon = 30 #Randomize insite of iteration
    
    #Generate the basic map where each coordinate is at z = 0
    world_coordinates = [] #(x,y,z)
    for x in range(GAME_WIDTH/10): #Divide by the width of each tile
        for y in range(GAME_HEIGHT/10):
            world_coordinates.append([x,y,0])
    
    #Generate the heightmap
    for i in range(iterations):
        print 'Iteration: ', i
        
        #Fire the cannon
        radius_cannon = random.randrange(10,20)
        #Move the cannon by choosing a random coordinate and draw a circle around the coordinate
        #One can here define the largest radius to where the cannon will be moved next iteration
        #to avoid the particles being scattered over the entire map
        random_coordinate = world_coordinates[random.randrange(0,len(world_coordinates))]
        subsequence = []
        for coordinate in world_coordinates:
            #Make a circular selection with euclidean distance to find where the cannon can fire
            if math.sqrt((random_coordinate[0]-coordinate[0])**2 + (random_coordinate[1]-coordinate[1])**2) <= radius_cannon:
                subsequence.append(coordinate)

        #Find random drop points within sequence
        drop_points = []
        particles = random.randrange(50,100)
        for i in range(particles):
            random_coordinate = random.randrange(0,len(subsequence))
            drop_points.append(subsequence[random_coordinate])
        

        #Agitation
        for drop_point in drop_points:
            possible_coordinates = []
            for coordinate in world_coordinates:
                #Dont store the coordinate of the drop point and find the circular section
                if (
                    coordinate != drop_point and 
                    math.sqrt((drop_point[0]-coordinate[0])**2 + (drop_point[1]-coordinate[1])**2) <= stability_radius
                ): 
                    possible_coordinates.append(coordinate)
            
            #Sort the list to find the coordinate with the lowest z value
            possible_coordinates.sort(key=lambda x: x[2])
            
            lowest = possible_coordinates[0]
            
            #Compare the z values
            if lowest[2] < drop_point[2]:
                #Increase the z of the point
                index = world_coordinates.index(lowest)
                world_coordinates[index][2] += height_change
            else:
                index = world_coordinates.index(drop_point)
                world_coordinates[index][2] += height_change
                
    return world_coordinates